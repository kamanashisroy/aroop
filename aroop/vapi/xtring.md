
String types
==============

Aroop contains special support for strings. While `string` class is originally the character array in C output, the `xtring` contains some extra features. Xtring has support for,

- Embeded/stack allocated container.
- Stack allocated string.
- Heap allocated string.
- A hash value and precalculated length value.
- You can make a string immutable.

The `extring` is of `struct` type so it can reduce memory allocation in some cases. It supports [flyweight pattern](http://en.wikipedia.org/wiki/Flyweight_pattern) to reduce data duplication and copying. You can always get _extring_ from _xtring_ calling fly() method.

Declaration
=============

The strings can be referenced in your code when it is allocated in heap. You can avoid memory copy by just referencing the heap string. For example, if you have a string named `hello`, you may define it like the following.

```vala
xtring hello = new xtring.copy_static_string("hello");
```

This will allocate a memory in heap for *xtring* structure as well as the "hello" string. You can do either [deep_copy](http://en.wikipedia.org/wiki/Deep_copy#Deep_copy) or [shallow_copy](http://en.wikipedia.org/wiki/Deep_copy#Shallow_copy) or [copy_on_demand](http://en.wikipedia.org/wiki/Deep_copy#Lazy_copy) of this string.

Again you can also allocate memory in stack.

```vala
extring hello = extring.set_static_string("hello"); // no new keyword is needed as it is allocated in stack.
```

The above code will keep the string totally in stack memory. You may also allocate stack memory if you want like the following.

```vala
extring hello = extring.stack(128);
hello.concat_string("hello");
```

Copying
=======

Now suppose you want to pass by value and set the extring parameter to a method. You can do that like the following.

```vala
public void getAs(extring*content) {
	content.rebuild_and_copy_on_demand(&cache);
}
```

Sandbox
========
You can copy a string into stack for processing.

```vala
extring sandbox = extring.stack_copy_extring(immutablextring);
```

Factory
========

You can also create factory for _xstring_ and build them.

```vala
extring src = extring.set_static_string("I shall be in the factory memory");
Factory<xtring> myTxtFactory = Factory<xtring>.for_type();
xtring x = xtring.factory_build_and_copy_deep(&myTxtFactory,&src);
```

You can even build it in searchable factory.

```vala
SearchableFactory<SearchableString> myTxtFactory = SearchableFactory<SearchableString>.for_type(); // searcable factory
SearchableString x = SearchableString.factory_build_and_copy_deep(&myTxtFactory,&src);
```

Note that the _xtring_ built in the factory will not be available when the factory is destroyed. So be sure to scope them in the boundary of factory existance(do not let others internalize them).

Error generated by returning extring in a method
===============================================

Suppose you have an instance variable of type extring. If you return this in a method, then it will be freed in the caller function resulting in double free. You need to take special care about this.

TODO: write more about copying and referencing strings.

