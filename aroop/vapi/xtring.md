
String types
==============

Aroop contains special support for strings. While `string` class is originally the character array in C output, the `xtring` contains some extra features. Xtring has support for,

- Embeded/stack allocated container.
- Stack allocated string.
- Heap allocated string.
- A hash value and precalculated length value.
- You can make a string immutable.

The `extring` is of `struct` type so it can reduce memory allocation in some cases. It supports [flyweight pattern](http://en.wikipedia.org/wiki/Flyweight_pattern) to reduce data duplication and copying. You can always get _extring_ from _xtring_ calling fly() method.

Declaration
=============

The strings can be referenced in your code when it is allocated in heap. You can avoid memory copy by just referencing the heap string. For example, if you have a string named `hello`, you may define it like the following.

```vala
xtring hello = new xtring.copy_static_string("hello");
```

This will allocate a memory in heap for *xtring* structure as well as the "hello" string. You can do either [deep_copy](http://en.wikipedia.org/wiki/Deep_copy#Deep_copy) or [shallow_copy](http://en.wikipedia.org/wiki/Deep_copy#Shallow_copy) or [copy_on_demand](http://en.wikipedia.org/wiki/Deep_copy#Lazy_copy) of this string.

Again you can also allocate memory in stack.

```vala
extring hello = extring.set_static_string("hello"); // no new keyword is needed as it is allocated in stack.
```

The above code will keep the string totally in stack memory. You may also allocate stack memory if you want like the following.

```vala
extring hello = extring.stack(128);
hello.concat_string("hello");
```

Copying
=======

Now suppose you want to pass by value and set the extring parameter to a method. You can do that like the following.

```vala
public void getAs(extring*content) {
	content.rebuild_and_copy_on_demand(&cache);
}
```

Sandbox
========
You can copy a string into stack for processing.

```vala
extring sandbox = extring.stack_copy_extring(immutablextring);
```

Heap memory
===========
Heap memory is obvious in some cases. The `extring.rebuild_in_heap(int size)` can be used to allocate memory space in any string type.

```vala
extring heap = extring();
heap.rebuild_in_heap(128);
heap.concat_string("I shall be in the heap memory");
```

Heap memory can be used if the string is set as output. For example, the following method adds suffix to a given string.

```vala
void addSuffix(extring*input, extring*suffix, extring*output) {
	output.rebuild_in_heap(input.length()+suffix.length()+1);
	output.concat(input);
	output.concat(suffix);
}
```

Traversing
===========

Each byte of the xtring can be accessed as follows,

```vala
extring content = extring.stack(128); // allocate 128 bytes in stack memory
content.concat_string("hello\nworld\n"); // copy "hello\nworld\n"
extring line = extring.stack(content.length()); // allocate memory space for each line
int i = 0;
for(i = 0; i < content.length(); i++) { // traverse all the elements starting from 0 to content.length()
	uchar ch = content.char_at(i); // get the character at index i
	if(ch == '\n') { // check if it is line break
		line.zero_terminate(); // null terminate the string (as in C strings are null terminated, so printing the string needs to be null terminated)
		print("%s\n", line.to_string()); // show the line
		line.truncate(); // it sets the line length to 0, so that next line can be added here
		continue;
	}
	line.concat_char(ch); // concat ch to the line 
}
```

Factory
========

You can also create factory for _xstring_ and build them.

```vala
extring src = extring.set_static_string("I shall be in the factory memory");
Factory<xtring> myTxtFactory = Factory<xtring>.for_type();
xtring x = xtring.factory_build_and_copy_deep(&myTxtFactory,&src);
```

You can even build it in searchable factory.

```vala
SearchableFactory<SearchableString> myTxtFactory = SearchableFactory<SearchableString>.for_type(); // searcable factory
SearchableString x = SearchableString.factory_build_and_copy_deep(&myTxtFactory,&src);
```

Note that the _xtring_ built in the factory will not be available when the factory is destroyed. So be sure to scope them in the boundary of factory existance(do not let others internalize them).

Error generated by returning extring in a method
===============================================

Suppose you have an instance variable of type extring. If you return this in a method, then it will be freed in the caller function resulting in double free. You need to take special care about this.

TODO: write more about copying and referencing strings.

